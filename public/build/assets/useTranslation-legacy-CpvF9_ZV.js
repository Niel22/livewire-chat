System.register(["./app-legacy-Z1_F-9fD.js"],function(e,n){"use strict";var s,t,a;return{setters:[e=>{s=e.r,t=e.I,a=e.J}],execute:function(){const n={},r=(e,s,t,a)=>{u(t)&&n[t]||(u(t)&&(n[t]=new Date),((e,n,s,t)=>{const a=[s,{code:n,...t||{}}];if(e?.services?.logger?.forward)return e.services.logger.forward(a,"warn","react-i18next::",!0);u(a[0])&&(a[0]=`react-i18next:: ${a[0]}`),e?.services?.logger?.warn?e.services.logger.warn(...a):console?.warn&&console.warn(...a)})(e,s,t,a))},i=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),n()};e.on("initialized",s)}},o=(e,n,s)=>{e.loadNamespaces(n,i(e,s))},c=(e,n,s,t)=>{if(u(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return o(e,s,t);s.forEach(n=>{e.options.ns.indexOf(n)<0&&e.options.ns.push(n)}),e.loadLanguages(n,i(e,t))},u=e=>"string"==typeof e,l=s.createContext();class g{constructor(){this.usedNamespaces={}}addUsedNamespaces(e){e.forEach(e=>{this.usedNamespaces[e]||(this.usedNamespaces[e]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const d=(e,n,s,t)=>e.getFixedT(n,s,t);e("u",(e,n={})=>{const{i18n:i}=n,{i18n:f,defaultNS:p}=s.useContext(l)||{},N=i||f||t();if(N&&!N.reportNamespaces&&(N.reportNamespaces=new g),!N){r(N,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const e=(e,n)=>{return u(n)?n:"object"==typeof(s=n)&&null!==s&&u(n.defaultValue)?n.defaultValue:Array.isArray(e)?e[e.length-1]:e;var s},n=[e,{},!1];return n.t=e,n.i18n={},n.ready=!1,n}N.options.react?.wait&&r(N,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const h={...a(),...N.options.react,...n},{useSuspense:m,keyPrefix:w}=h;let y=e||p||N.options?.defaultNS;y=u(y)?[y]:y||["translation"],N.reportNamespaces.addUsedNamespaces?.(y);const b=(N.isInitialized||N.initializedStoreOnce)&&y.every(e=>((e,n,s={})=>n.languages&&n.languages.length?n.hasLoadedNamespace(e,{lng:s.lng,precheck:(n,t)=>{if(s.bindI18n&&s.bindI18n.indexOf("languageChanging")>-1&&n.services.backendConnector.backend&&n.isLanguageChangingTo&&!t(n.isLanguageChangingTo,e))return!1}}):(r(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0))(e,N,h)),E=((e,n,t,a)=>s.useCallback(d(e,n,t,a),[e,n,t,a]))(N,n.lng||null,"fallback"===h.nsMode?y:y[0],w),x=()=>E,I=()=>d(N,n.lng||null,"fallback"===h.nsMode?y:y[0],w),[S,T]=s.useState(x);let v=y.join();n.lng&&(v=`${n.lng}${v}`);const C=((e,n)=>{const t=s.useRef();return s.useEffect(()=>{t.current=e},[e,n]),t.current})(v),O=s.useRef(!0);s.useEffect(()=>{const{bindI18n:e,bindI18nStore:s}=h;O.current=!0,b||m||(n.lng?c(N,n.lng,y,()=>{O.current&&T(I)}):o(N,y,()=>{O.current&&T(I)})),b&&C&&C!==v&&O.current&&T(I);const t=()=>{O.current&&T(I)};return e&&N?.on(e,t),s&&N?.store.on(s,t),()=>{O.current=!1,N&&e&&e?.split(" ").forEach(e=>N.off(e,t)),s&&N&&s.split(" ").forEach(e=>N.store.off(e,t))}},[N,v]),s.useEffect(()=>{O.current&&b&&T(x)},[N,w,b]);const k=[S,N,b];if(k.t=S,k.i18n=N,k.ready=b,b)return k;if(!b&&!m)return k;throw new Promise(e=>{n.lng?c(N,n.lng,y,()=>e()):o(N,y,()=>e())})})}}});
